# k8s-Study
추석 - 인프런 쿠버 강의를 보며 공부해보자



# 컨테이너 오케스트레이션 (서버를 관리한다는 것)

VM
서버하나에 가상머신이 여러개!
조금 느리고 관리가 불편하지만 괜찮다.

클라우드, 특정 벤더의 의존성이 생기기 때문에 사용하기 어렵고
기본적으로 하이퍼바이저가 있기에 성능이 느리다.

이때 !
도커가 나온다.

모든 실행환경을 도커로 !

특정 클라우드 벤더에 종송적이지 않고, 언어, 프레임워크에 상관없이
애플리케이션을 동일한 방식으로 관리 ( 오픈소스 )

aws -> gcp 

Developer 가 코드를 짜고 -> Build ( 도커 이미지를 만들고 ) -> 만든이미지를 도커허브, 저장소에 저장하고 
-> 그 도커이미지를 컨테이너를 실행

이 과정이 도커를 도입하고 나서 이 일련의 프로세스가 똑같아진다. 원래는 플랫폼이 다를때 이게 어려웟지만 이게 이롷게 된거지..


이제 이렇게 도커 컨테이너 여러개를 만들어서 사용하다보니까! 불편함이 있는거야. 너무많은 컨테이너가 있기 때문에
이렇게 많은 수천개 수만개! 의 컨테이너로 인해 관리가쫌..............


dcoker stop app && docker run .. : server 1
dcoker stop app && docker run .. : server 2
dcoker stop app && docker run .. : server 3

또한 서버가 여러개가 있는데 여기 중에서 컨테이너가 실행되고 있는지 모르겠어! 즉, 각 컨테이너가 실행중인 서버를
모니터링해주고 관리해야돼!


롤아웃, 롤백 ( 버전업하고 싶거나 )

Proxy { web : "192.168.0.200"  }
LoadBalancer { 10.0.0.100 , 10.0.0.101 }

web container 1
web container 2


서비스 이상, 부하 모니터링 은 어떻게할까?

복잡한 컨테이너 환경을 효과적으로 관리하기 위한 도구 : 컨테이너 오케스트레이션

서버관리자가 하는일을 대신해주는 프로그램을 만드는것 !

클러스터 : 클러스터 단위로 컨테이너 여러개를 하나로 합쳐서 추상화해서 관리를 한다 
마스터 서버를 앞에다가 두고 ! 클러스터 단위의 여러개의 도커 컨테이너를 관리한다 
즉, 마스터한테 명령을 잘해주면된다. !

복제를 3개 해주는 상태관리도 있다.
{
  image : "app1"
  replicas : 3
}

배포 버전관리도 있다!
서비스 디스커버리도 있고!
불륨설정도 가능하다! Node 1에는 aws , Node 2에는 GCP 등!


# 어떤것을 공부할까?

일련의 프로세스는

1.개발자가 코드를 작성
2. git merge request or push!
3. Build Test, Create Container Image, Push Container Image - Docker Registry 
4. Deploy : New or Update 
5. Kubernates 
6. Scale Out 

도커 컨테이너 실행하기  - 도커와 도커컴포즈를 이요한 멀티 컨테이너 
쿠버네티스에 컨테이너 배포하기 
외부 접속 설정하기
스케일 아웃하기 - 부하에 따른 컨테이너 관리 
그외 고급기능 소개



# 쿠버네티스 소개

컨테이너화된 애플리케이션을 자동으로 배포, 스케일링 및 그룹화
컨테이너를 쉽게 관리하고 연결하기 위해서 논리적은 단위로 그룹화


클라우드 환경에서 어떻게 애플리케이션을 배포하는게 좋은걸까?

! 잠깐!! 내가 궁금해서 방금 찾아본 것 

'Pod'란 쿠버네티스에서 최소 배포 단위로 하나 이상의 컨테이너를 포함한다. Docker를 사용해본 사용자라면 알듯 Docker에서는 최소의 배포 단위가 컨테이너이다. 하지만 쿠버네티스는 하나의 컨테이너가 아닌 컨테이너 및 네트워크, 스토리지가 포함된 Pod로 배포한다.

JAR는 여러개의 자바 클래스 파일과, 클래스들이 이용하는 관련 리소스 및 메타데이터를 하나의 파일로 모아서 자바 플랫폼에 응용 소프트웨어나 라이브러리를 배포하기 위한 소프트웨어 패키지 파일 포맷이다.


# 쿠버네티스 배포 데모

kubectl get node
kubectl get namesapce 
kubectl get po -n monitroting



# 쿠버네티스 아키텍처 

누군가 컨테이너 1개를 띄어줘!! 라고 할수있지.
컨테이너 1개 생성!? 하고 메모를 한다.
그리고 계속 확인을 해봐야한다. 컨테이너가 계속 떠있는지 !

원하는 상태 컨테이너 1개 : 실제 떠있는 상태 1개 - 안정적인 상태
현재상태 == 원하는 상태  : Current State == Desired State
만약 다르면 조치를 해줘야한다! 

상태체크 (Observe) -> 차이점발견 (Diff) -> 조치 (Act)
이러한 Loop 를 계속 돈다.!!


음 또 요청이들어왔다. 음... 새 컨테이너는 어디에 배포하지 ?
근데 이렇게 매일 어디에 배포하는지 확인하고 하는게 귀찮을 수 있다!

그래서 Scheduler 를 뽑을 수 있어!! ( 두번째 서버에 넣으면될것같은데!? 라는 생각)
또 컨테이너 상태를 체크할 사람을 뽑자! Controller를 뽑자!!
또 여러가지 부가적인것도 확인하는 것을 뽑을 사람이 필요해! 뽑아!!


Desired State : Replication Controller , Endpoint Controller, Namespace Controller 등등 
이렇게 체크하는 컨트롤러를 만들 수 있다 ! ! ! ! 

![image](https://user-images.githubusercontent.com/86240112/133997340-320b99c6-c1ee-4855-9668-fb80aaef6bed.png)

etcd : 데이터베이스? 같은느낌 - 모든 상태와 데이터를 저장, key -value 형태로 데이터저장 
현재 상태를 전부 저장하기 때문에 중요해에! 백업은 필수다 

Master 상세 - API server : 상태를 바꾸거나 조회 , etcd 와 유일하게 통신하는 모듈 , Rest api 형태로 제공!
권한을 체크하여 적절한 권한이 없을 경우 요청을 차단 ! 조회나 요청을 이 Api Server 를 통해서 ! ! ! ! !

Master 상세 - Scheduler : 새로 생성된 Pod를 감지하고 실행할 노드를 선택, 노드의 현재상태와 Pod 요구사항 체크
노드에 라벨을 부여


Master 상세 - Controller : 복제컨트롤러 노드 컨트롤러 엔드포인트컨트롤러 등등 많다. 끊임없이 상태를 체크하고 원하는 상태를 유지한다. 단일 프로세스로 실행 ! ! ! ! ! 


조회흐름 ! ! ! Controller 가 ApiServer 에게 정보를 조회할게요! 하면 이제 API Server 는 권한 체크를 하고 etcd 에 그 상태를 조회하고 보내준다 ! 그리고 지금 원하는 상태가 변경되었다 ! 이런것도 알려준다. 
그럼 Controller 을 그 변경사항을 알고나서 변경을 해주고! API Server에 변경한 것을 알려줌 . 갱싱 권한 체크하고 etcd 에 변화함


그럼 이제 Node 를 보자!

하나는 Proxy 하나는 Kublete (큐블릿) 이 뜬다.
마스터와 통신할때 API Server랑만 통신을 한다!

큐블릿이 !! Pod 이랑 통신을 한다 !!
각 노드에서 실행!
큐블릿은 각 노드에 꼭 떠있어야한다. 이 큐블릿이 Pod을 실행하고 중지하기 때문에!! 

프록시 !! 네트워크 프록시와 부하분산 역할, 실제로 하는 역할은 설정! 

![image](https://user-images.githubusercontent.com/86240112/133998321-ef07d63b-472b-45a2-bffb-0a26118929e9.png)


-- 흐름

어떤 관리자가 요청을 하는거지 Pod을 추가해줘!
API Server에 요청을 하는거지!
요청을 받은 API Server는 etcd에 Pod - 생성 요청이 왔다고 적어놓는다.
Controller 가 계속 체크를 한다. 새 Pod 확인을 계속하다가 요청을 보고! 할당하는 요청을 한다!
Api Server는 Pod 할당요청을 해라! 라고 etcd에요청 !
스케줄러는 이제 그 요청을 계속 보다가 어디에 어떤 node에 Pod를 할당할까.. 생각하다가 APi Server에 요청!

Api server는 특정 노드에 할당하는데 실행되기 전이다! 라고 etcd에 상태변화!
이제 '큐블릿'이 실행이 안된 pod이인나 확인하다가! 확인하고 pod를 생성한다! 큐블릿이!

이제 다시 API Sever에서는 그 정보를 보고 Etcd에 pod 할당되어있고 실행되어있따고 업데이트를 한다!!

그래서 계속 Controller Kubelete Api Server Etcd 는 계속~~~~ 실행되고있어 항상 체크하면서 업데이트하고!




































































